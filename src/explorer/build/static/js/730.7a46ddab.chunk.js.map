{"version":3,"file":"static/js/730.7a46ddab.chunk.js","mappings":"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","sources":["../node_modules/graphql/version.mjs","../node_modules/graphql/jsutils/isPromise.mjs","../node_modules/graphql/jsutils/toError.mjs","../node_modules/graphql/error/locatedError.mjs","../node_modules/graphql/execution/execute.mjs","../node_modules/graphql/jsutils/memoize3.mjs","../node_modules/graphql/jsutils/promiseReduce.mjs","../node_modules/graphql/jsutils/promiseForObject.mjs","../node_modules/graphql/graphql.mjs","../node_modules/graphql/jsutils/isAsyncIterable.mjs","../node_modules/graphql/execution/mapAsyncIterator.mjs","../node_modules/graphql/execution/subscribe.mjs","../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs","../node_modules/graphql/utilities/getOperationAST.mjs","../node_modules/graphql/utilities/getOperationRootType.mjs","../node_modules/graphql/utilities/introspectionFromSchema.mjs","../node_modules/graphql/utilities/extendSchema.mjs","../node_modules/graphql/utilities/buildASTSchema.mjs","../node_modules/graphql/utilities/lexicographicSortSchema.mjs","../node_modules/graphql/utilities/printSchema.mjs","../node_modules/graphql/utilities/concatAST.mjs","../node_modules/graphql/utilities/separateOperations.mjs","../node_modules/graphql/utilities/stripIgnoredCharacters.mjs","../node_modules/graphql/utilities/assertValidName.mjs","../node_modules/graphql/utilities/findBreakingChanges.mjs"],"sourcesContent":["// Note: This file is autogenerated using \"resources/gen-version.js\" script and\n// automatically updated by \"npm version\" command.\n\n/**\n * A string containing the version of the GraphQL.js library\n */\nexport const version = '16.3.0';\n/**\n * An object containing the components of the GraphQL.js version string\n */\n\nexport const versionInfo = Object.freeze({\n  major: 16,\n  minor: 3,\n  patch: 0,\n  preReleaseTag: null,\n});\n","/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\nexport function isPromise(value) {\n  return (\n    typeof (value === null || value === void 0 ? void 0 : value.then) ===\n    'function'\n  );\n}\n","import { inspect } from './inspect.mjs';\n/**\n * Sometimes a non-error is thrown, wrap it as an Error instance to ensure a consistent Error interface.\n */\n\nexport function toError(thrownValue) {\n  return thrownValue instanceof Error\n    ? thrownValue\n    : new NonErrorThrown(thrownValue);\n}\n\nclass NonErrorThrown extends Error {\n  constructor(thrownValue) {\n    super('Unexpected error value: ' + inspect(thrownValue));\n    this.name = 'NonErrorThrown';\n    this.thrownValue = thrownValue;\n  }\n}\n","import { toError } from '../jsutils/toError.mjs';\nimport { GraphQLError } from './GraphQLError.mjs';\n/**\n * Given an arbitrary value, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\n\nexport function locatedError(rawOriginalError, nodes, path) {\n  var _nodes;\n\n  const originalError = toError(rawOriginalError); // Note: this uses a brand-check to support GraphQL errors originating from other contexts.\n\n  if (isLocatedGraphQLError(originalError)) {\n    return originalError;\n  }\n\n  return new GraphQLError(\n    originalError.message,\n    (_nodes = originalError.nodes) !== null && _nodes !== void 0\n      ? _nodes\n      : nodes,\n    originalError.source,\n    originalError.positions,\n    path,\n    originalError,\n  );\n}\n\nfunction isLocatedGraphQLError(error) {\n  return Array.isArray(error.path);\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.mjs';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\n  _collectSubfields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    returnType,\n    fieldNodes,\n  ),\n);\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n  try {\n    const { operation } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(\n        (data) => buildResponse(data, exeContext.errors),\n        (error) => {\n          exeContext.errors.push(error);\n          return buildResponse(null, exeContext.errors);\n        },\n      );\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\n * Given a completed execution context and data, build the `{ errors, data }`\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0\n    ? {\n        data,\n      }\n    : {\n        errors,\n        data,\n      };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n *\n * @internal\n */\n\nexport function assertValidExecutionArguments(\n  schema,\n  document,\n  rawVariableValues,\n) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null ||\n    isObjectLike(rawVariableValues) ||\n    devAssert(\n      false,\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\n    );\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * @internal\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n\n          operation = definition;\n        } else if (\n          ((_definition$name = definition.name) === null ||\n          _definition$name === void 0\n            ? void 0\n            : _definition$name.value) === operationName\n        ) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const variableDefinitions =\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\n    _operation$variableDe !== void 0\n      ? _operation$variableDe\n      : [];\n  const coercedVariableValues = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues !== null && rawVariableValues !== void 0\n      ? rawVariableValues\n      : {},\n    {\n      maxErrors: 50,\n    },\n  );\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver:\n      fieldResolver !== null && fieldResolver !== void 0\n        ? fieldResolver\n        : defaultFieldResolver,\n    typeResolver:\n      typeResolver !== null && typeResolver !== void 0\n        ? typeResolver\n        : defaultTypeResolver,\n    subscribeFieldResolver:\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\n        ? subscribeFieldResolver\n        : defaultFieldResolver,\n    errors: [],\n  };\n}\n/**\n * Implements the \"Executing operations\" section of the spec.\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      `Schema is not configured to execute ${operation.operation} operation.`,\n      operation,\n    );\n  }\n\n  const rootFields = collectFields(\n    exeContext.schema,\n    exeContext.fragments,\n    exeContext.variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        path,\n        rootFields,\n      );\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\n\nfunction executeFieldsSerially(\n  exeContext,\n  parentType,\n  sourceValue,\n  path,\n  fields,\n) {\n  return promiseReduce(\n    fields.entries(),\n    (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldNodes,\n        fieldPath,\n      );\n\n      if (result === undefined) {\n        return results;\n      }\n\n      if (isPromise(result)) {\n        return result.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n\n      results[responseName] = result;\n      return results;\n    },\n    Object.create(null),\n  );\n}\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(\n      exeContext,\n      parentType,\n      sourceValue,\n      fieldNodes,\n      fieldPath,\n    );\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n  return promiseForObject(results);\n}\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * serialize scalars, or execute the sub-selection-set for objects.\n */\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn =\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\n    _fieldDef$resolve !== void 0\n      ? _fieldDef$resolve\n      : exeContext.fieldResolver;\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    parentType,\n    path,\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      exeContext.variableValues,\n    ); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then((resolved) =>\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\n      );\n    } else {\n      completed = completeValue(\n        exeContext,\n        returnType,\n        fieldNodes,\n        info,\n        path,\n        result,\n      );\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError) => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\n * @internal\n */\n\nexport function buildResolveInfo(\n  exeContext,\n  fieldDef,\n  fieldNodes,\n  parentType,\n  path,\n) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\n      );\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  } // If field type is Object, execute and complete all sub-selections.\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      path,\n      result,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n  false ||\n    invariant(\n      false,\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\n    );\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\nfunction completeListValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\n    );\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) =>\n          completeValue(\n            exeContext,\n            itemType,\n            fieldNodes,\n            info,\n            itemPath,\n            resolved,\n          ),\n        );\n      } else {\n        completedItem = completeValue(\n          exeContext,\n          itemType,\n          fieldNodes,\n          info,\n          itemPath,\n          item,\n        );\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, (rawError) => {\n          const error = locatedError(\n            rawError,\n            fieldNodes,\n            pathToArray(itemPath),\n          );\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\n    );\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\nfunction completeAbstractValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn =\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\n    _returnType$resolveTy !== void 0\n      ? _returnType$resolveTy\n      : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          exeContext,\n          returnType,\n          fieldNodes,\n          info,\n          result,\n        ),\n        fieldNodes,\n        info,\n        path,\n        result,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      exeContext,\n      returnType,\n      fieldNodes,\n      info,\n      result,\n    ),\n    fieldNodes,\n    info,\n    path,\n    result,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName,\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  result,\n) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      fieldNodes,\n    );\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\n    );\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      fieldNodes,\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      fieldNodes,\n    );\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\n      fieldNodes,\n    );\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\nfunction completeObjectValue(\n  exeContext,\n  returnType,\n  fieldNodes,\n  info,\n  path,\n  result,\n) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(\n          exeContext,\n          returnType,\n          result,\n          path,\n          subFieldNodes,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\n    fieldNodes,\n  );\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\nexport const defaultTypeResolver = function (\n  value,\n  contextValue,\n  info,\n  abstractType,\n) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\nexport const defaultFieldResolver = function (\n  source,\n  args,\n  contextValue,\n  info,\n) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the three introspection fields,\n * __schema, __type and __typename. __typename is special because\n * it can always be queried as a field, even in situations where no\n * other fields are allowed, like on a Union. __schema and __type\n * could get automatically added to the query type, but that would\n * require mutating type definitions, which would cause issues.\n *\n * @internal\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (\n    fieldName === SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return SchemaMetaFieldDef;\n  } else if (\n    fieldName === TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n","/**\n * Memoizes the provided three-argument function.\n */\nexport function memoize3(fn) {\n  let cache0;\n  return function memoized(a1, a2, a3) {\n    if (cache0 === undefined) {\n      cache0 = new WeakMap();\n    }\n\n    let cache1 = cache0.get(a1);\n\n    if (cache1 === undefined) {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    let cache2 = cache1.get(a2);\n\n    if (cache2 === undefined) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    let fnResult = cache2.get(a3);\n\n    if (fnResult === undefined) {\n      fnResult = fn(a1, a2, a3);\n      cache2.set(a3, fnResult);\n    }\n\n    return fnResult;\n  };\n}\n","import { isPromise } from './isPromise.mjs';\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nexport function promiseReduce(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n\n  for (const value of values) {\n    accumulator = isPromise(accumulator)\n      ? accumulator.then((resolved) => callbackFn(resolved, value))\n      : callbackFn(accumulator, value);\n  }\n\n  return accumulator;\n}\n","/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nexport function promiseForObject(object) {\n  return Promise.all(Object.values(object)).then((resolvedValues) => {\n    const resolvedObject = Object.create(null);\n\n    for (const [i, key] of Object.keys(object).entries()) {\n      resolvedObject[key] = resolvedValues[i];\n    }\n\n    return resolvedObject;\n  });\n}\n","import { devAssert } from './jsutils/devAssert.mjs';\nimport { isPromise } from './jsutils/isPromise.mjs';\nimport { parse } from './language/parser.mjs';\nimport { validateSchema } from './type/validate.mjs';\nimport { validate } from './validation/validate.mjs';\nimport { execute } from './execution/execute.mjs';\n/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Accepts either an object with named arguments, or individual arguments:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value or method on the source value with the field's name).\n * typeResolver:\n *    A type resolver function to use when none is provided by the schema.\n *    If not provided, the default type resolver is used (which looks for a\n *    `__typename` field or alternatively calls the `isTypeOf` method).\n */\n\nexport function graphql(args) {\n  // Always return a Promise for a consistent API.\n  return new Promise((resolve) => resolve(graphqlImpl(args)));\n}\n/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\nexport function graphqlSync(args) {\n  const result = graphqlImpl(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction graphqlImpl(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const {\n    schema,\n    source,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  } = args; // Validate Schema\n\n  const schemaValidationErrors = validateSchema(schema);\n\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors,\n    };\n  } // Parse\n\n  let document;\n\n  try {\n    document = parse(source);\n  } catch (syntaxError) {\n    return {\n      errors: [syntaxError],\n    };\n  } // Validate\n\n  const validationErrors = validate(schema, document);\n\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors,\n    };\n  } // Execute\n\n  return execute({\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  });\n}\n","/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n  return (\n    typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0\n      ? void 0\n      : maybeAsyncIterable[Symbol.asyncIterator]) === 'function'\n  );\n}\n","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(result) {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return {\n        value: await callback(result.value),\n        done: false,\n      };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n\n    async return() {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : {\n            value: undefined,\n            done: true,\n          };\n    },\n\n    async throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n\n      throw error;\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { collectFields } from './collectFields.mjs';\nimport {\n  assertValidExecutionArguments,\n  buildExecutionContext,\n  buildResolveInfo,\n  execute,\n  getFieldDef,\n} from './execute.mjs';\nimport { mapAsyncIterator } from './mapAsyncIterator.mjs';\nimport { getArgumentValues } from './values.mjs';\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\nexport async function subscribe(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 ||\n    devAssert(\n      false,\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\n    );\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    subscribeFieldResolver,\n  } = args;\n  const resultOrStream = await createSourceEventStream(\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    subscribeFieldResolver,\n  );\n\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  } // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  const mapSourceToResponse = (payload) =>\n    execute({\n      schema,\n      document,\n      rootValue: payload,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n    }); // Map every source value to a ExecutionResult value as described above.\n\n  return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\nexport async function createSourceEventStream(\n  schema,\n  document,\n  rootValue,\n  contextValue,\n  variableValues,\n  operationName,\n  subscribeFieldResolver,\n) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext({\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    subscribeFieldResolver,\n  }); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext,\n    };\n  }\n\n  try {\n    const eventStream = await executeSubscription(exeContext); // Assert field returned an event stream, otherwise yield an error.\n\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(\n        'Subscription field must return Async Iterable. ' +\n          `Received: ${inspect(eventStream)}.`,\n      );\n    }\n\n    return eventStream;\n  } catch (error) {\n    // If it GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n    // Otherwise treat the error as a system-class error and re-throw it.\n    if (error instanceof GraphQLError) {\n      return {\n        errors: [error],\n      };\n    }\n\n    throw error;\n  }\n}\n\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } =\n    exeContext;\n  const rootType = schema.getSubscriptionType();\n\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      operation,\n    );\n  }\n\n  const rootFields = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n  );\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      fieldNodes,\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    exeContext,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    var _fieldDef$subscribe;\n\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue; // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n    const resolveFn =\n      (_fieldDef$subscribe = fieldDef.subscribe) !== null &&\n      _fieldDef$subscribe !== void 0\n        ? _fieldDef$subscribe\n        : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info);\n\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n\n    return eventStream;\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n","import { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType } from '../../../type/definition.mjs';\nimport { isIntrospectionType } from '../../../type/introspection.mjs';\n\n/**\n * Prohibit introspection queries\n *\n * A GraphQL document is only valid if all fields selected are not fields that\n * return an introspection type.\n *\n * Note: This rule is optional and is not part of the Validation section of the\n * GraphQL Specification. This rule effectively disables introspection, which\n * does not reflect best practices and should only be done if absolutely necessary.\n */\nexport function NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type = getNamedType(context.getType());\n\n      if (type && isIntrospectionType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`,\n            node,\n          ),\n        );\n      }\n    },\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\n\nexport function getOperationAST(documentAST, operationName) {\n  let operation = null;\n\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n\n      if (operationName == null) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (\n        ((_definition$name = definition.name) === null ||\n        _definition$name === void 0\n          ? void 0\n          : _definition$name.value) === operationName\n      ) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n","import { GraphQLError } from '../error/GraphQLError.mjs';\n\n/**\n * Extracts the root type of the operation from the schema.\n *\n * @deprecated Please use `GraphQLSchema.getRootType` instead. Will be removed in v17\n */\nexport function getOperationRootType(schema, operation) {\n  if (operation.operation === 'query') {\n    const queryType = schema.getQueryType();\n\n    if (!queryType) {\n      throw new GraphQLError(\n        'Schema does not define the required query root type.',\n        operation,\n      );\n    }\n\n    return queryType;\n  }\n\n  if (operation.operation === 'mutation') {\n    const mutationType = schema.getMutationType();\n\n    if (!mutationType) {\n      throw new GraphQLError(\n        'Schema is not configured for mutations.',\n        operation,\n      );\n    }\n\n    return mutationType;\n  }\n\n  if (operation.operation === 'subscription') {\n    const subscriptionType = schema.getSubscriptionType();\n\n    if (!subscriptionType) {\n      throw new GraphQLError(\n        'Schema is not configured for subscriptions.',\n        operation,\n      );\n    }\n\n    return subscriptionType;\n  }\n\n  throw new GraphQLError(\n    'Can only have query, mutation and subscription operations.',\n    operation,\n  );\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { executeSync } from '../execution/execute.mjs';\nimport { getIntrospectionQuery } from './getIntrospectionQuery.mjs';\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\n\nexport function introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = {\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true,\n    ...options,\n  };\n  const document = parse(getIntrospectionQuery(optionsWithDefaults));\n  const result = executeSync({\n    schema,\n    document,\n  });\n  (!result.errors && result.data) || invariant(false);\n  return result.data;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { mapValue } from '../jsutils/mapValue.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../language/predicates.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.mjs';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.mjs';\nimport {\n  isSpecifiedScalarType,\n  specifiedScalarTypes,\n} from '../type/scalars.mjs';\nimport { assertSchema, GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDLExtension } from '../validation/validate.mjs';\nimport { getDirectiveValues } from '../execution/values.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\nconst stdTypeMap = keyMap(\n  [...specifiedScalarTypes, ...introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { parse } from '../language/parser.mjs';\nimport { specifiedDirectives } from '../type/directives.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { assertValidSDL } from '../validation/validate.mjs';\nimport { extendSchemaImpl } from './extendSchema.mjs';\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(documentAST, options) {\n  (documentAST != null && documentAST.kind === Kind.DOCUMENT) ||\n    devAssert(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    assertValidSDL(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives, // If specified directives were not explicitly declared, add them.\n    ...specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n  return new GraphQLSchema({ ...config, directives });\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  const document = parse(source, {\n    noLocation:\n      options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables:\n      options === null || options === void 0\n        ? void 0\n        : options.allowLegacyFragmentVariables,\n  });\n  return buildASTSchema(document, {\n    assumeValidSDL:\n      options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  });\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\n/**\n * Sort GraphQLSchema.\n *\n * This function returns a sorted copy of the given GraphQLSchema.\n */\n\nexport function lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(\n    sortByName(schemaConfig.types),\n    (type) => type.name,\n    sortNamedType,\n  );\n  return new GraphQLSchema({\n    ...schemaConfig,\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription),\n  });\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    } else if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME: TS Conversion\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    return typeMap[type.name];\n  }\n\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n\n  function sortDirective(directive) {\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      locations: sortBy(config.locations, (x) => x),\n      args: sortArgs(config.args),\n    });\n  }\n\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args),\n    }));\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => ({\n      ...field,\n      type: replaceType(field.type),\n    }));\n  }\n\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n\n  function sortNamedType(type) {\n    if (isScalarType(type) || isIntrospectionType(type)) {\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLObjectType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInterfaceType({\n        ...config,\n        interfaces: () => sortTypes(config.interfaces),\n        fields: () => sortFields(config.fields),\n      });\n    }\n\n    if (isUnionType(type)) {\n      const config = type.toConfig();\n      return new GraphQLUnionType({\n        ...config,\n        types: () => sortTypes(config.types),\n      });\n    }\n\n    if (isEnumType(type)) {\n      const config = type.toConfig();\n      return new GraphQLEnumType({\n        ...config,\n        values: sortObjMap(config.values, (value) => value),\n      });\n    }\n\n    if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      return new GraphQLInputObjectType({\n        ...config,\n        fields: () => sortInputFields(config.fields),\n      });\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n\n    false || invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  const sortedMap = Object.create(null);\n\n  for (const key of Object.keys(map).sort(naturalCompare)) {\n    sortedMap[key] = sortValueFn(map[key]);\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare(key1, key2);\n  });\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isPrintableAsBlockString } from '../language/blockString.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport {\n  DEFAULT_DEPRECATION_REASON,\n  isSpecifiedDirective,\n} from '../type/directives.mjs';\nimport { isIntrospectionType } from '../type/introspection.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nexport function printSchema(schema) {\n  return printFilteredSchema(\n    schema,\n    (n) => !isSpecifiedDirective(n),\n    isDefinedType,\n  );\n}\nexport function printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\n\nfunction isDefinedType(type) {\n  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type) => printType(type)),\n  ]\n    .filter(Boolean)\n    .join('\\n\\n');\n}\n\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n\n  return printDescription(schema) + `schema {\\n${operationTypes.join('\\n')}\\n}`;\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n * ```graphql\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *     subscription: Subscription\n *   }\n * ```\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nexport function printType(type) {\n  if (isScalarType(type)) {\n    return printScalar(type);\n  }\n\n  if (isObjectType(type)) {\n    return printObject(type);\n  }\n\n  if (isInterfaceType(type)) {\n    return printInterface(type);\n  }\n\n  if (isUnionType(type)) {\n    return printUnion(type);\n  }\n\n  if (isEnumType(type)) {\n    return printEnum(type);\n  }\n\n  if (isInputObjectType(type)) {\n    return printInputObject(type);\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction printScalar(type) {\n  return (\n    printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type)\n  );\n}\n\nfunction printImplementedInterfaces(type) {\n  const interfaces = type.getInterfaces();\n  return interfaces.length\n    ? ' implements ' + interfaces.map((i) => i.name).join(' & ')\n    : '';\n}\n\nfunction printObject(type) {\n  return (\n    printDescription(type) +\n    `type ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printInterface(type) {\n  return (\n    printDescription(type) +\n    `interface ${type.name}` +\n    printImplementedInterfaces(type) +\n    printFields(type)\n  );\n}\n\nfunction printUnion(type) {\n  const types = type.getTypes();\n  const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';\n  return printDescription(type) + 'union ' + type.name + possibleTypes;\n}\n\nfunction printEnum(type) {\n  const values = type\n    .getValues()\n    .map(\n      (value, i) =>\n        printDescription(value, '  ', !i) +\n        '  ' +\n        value.name +\n        printDeprecated(value.deprecationReason),\n    );\n  return printDescription(type) + `enum ${type.name}` + printBlock(values);\n}\n\nfunction printInputObject(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) => printDescription(f, '  ', !i) + '  ' + printInputValue(f),\n  );\n  return printDescription(type) + `input ${type.name}` + printBlock(fields);\n}\n\nfunction printFields(type) {\n  const fields = Object.values(type.getFields()).map(\n    (f, i) =>\n      printDescription(f, '  ', !i) +\n      '  ' +\n      f.name +\n      printArgs(f.args, '  ') +\n      ': ' +\n      String(f.type) +\n      printDeprecated(f.deprecationReason),\n  );\n  return printBlock(fields);\n}\n\nfunction printBlock(items) {\n  return items.length !== 0 ? ' {\\n' + items.join('\\n') + '\\n}' : '';\n}\n\nfunction printArgs(args, indentation = '') {\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n  if (args.every((arg) => !arg.description)) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return (\n    '(\\n' +\n    args\n      .map(\n        (arg, i) =>\n          printDescription(arg, '  ' + indentation, !i) +\n          '  ' +\n          indentation +\n          printInputValue(arg),\n      )\n      .join('\\n') +\n    '\\n' +\n    indentation +\n    ')'\n  );\n}\n\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + ': ' + String(arg.type);\n\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\n\nfunction printDirective(directive) {\n  return (\n    printDescription(directive) +\n    'directive @' +\n    directive.name +\n    printArgs(directive.args) +\n    (directive.isRepeatable ? ' repeatable' : '') +\n    ' on ' +\n    directive.locations.join(' | ')\n  );\n}\n\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return '';\n  }\n\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason,\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n\n  return ' @deprecated';\n}\n\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return '';\n  }\n\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL,\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\n\nfunction printDescription(def, indentation = '', firstInBlock = true) {\n  const { description } = def;\n\n  if (description == null) {\n    return '';\n  }\n\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description),\n  });\n  const prefix =\n    indentation && !firstInBlock ? '\\n' + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, '\\n' + indentation) + '\\n';\n}\n","import { Kind } from '../language/kinds.mjs';\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\n\nexport function concatAST(documents) {\n  const definitions = [];\n\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions,\n  };\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n","import { printBlockString } from '../language/blockString.mjs';\nimport { isPunctuatorTokenKind, Lexer } from '../language/lexer.mjs';\nimport { isSource, Source } from '../language/source.mjs';\nimport { TokenKind } from '../language/tokenKind.mjs';\n/**\n * Strips characters that are not significant to the validity or execution\n * of a GraphQL document:\n *   - UnicodeBOM\n *   - WhiteSpace\n *   - LineTerminator\n *   - Comment\n *   - Comma\n *   - BlockString indentation\n *\n * Note: It is required to have a delimiter character between neighboring\n * non-punctuator tokens and this function always uses single space as delimiter.\n *\n * It is guaranteed that both input and output documents if parsed would result\n * in the exact same AST except for nodes location.\n *\n * Warning: It is guaranteed that this function will always produce stable results.\n * However, it's not guaranteed that it will stay the same between different\n * releases due to bugfixes or changes in the GraphQL specification.\n *\n * Query example:\n *\n * ```graphql\n * query SomeQuery($foo: String!, $bar: String) {\n *   someField(foo: $foo, bar: $bar) {\n *     a\n *     b {\n *       c\n *       d\n *     }\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}\n * ```\n *\n * SDL example:\n *\n * ```graphql\n * \"\"\"\n * Type description\n * \"\"\"\n * type Foo {\n *   \"\"\"\n *   Field description\n *   \"\"\"\n *   bar: String\n * }\n * ```\n *\n * Becomes:\n *\n * ```graphql\n * \"\"\"Type description\"\"\" type Foo{\"\"\"Field description\"\"\" bar:String}\n * ```\n */\n\nexport function stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = '';\n  let wasLastAddedTokenNonPunctuator = false;\n\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    /**\n     * Every two non-punctuator tokens should have space between them.\n     * Also prevent case of non-punctuator token following by spread resulting\n     * in invalid token (e.g. `1...` is invalid Float token).\n     */\n\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += ' ';\n      }\n    }\n\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString(currentToken.value, {\n        minimize: true,\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n\n  return strippedBody;\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { assertName } from '../type/assertName.mjs';\n/* c8 ignore start */\n\n/**\n * Upholds the spec rules about naming.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function assertValidName(name) {\n  const error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n * @deprecated Please use `assertName` instead. Will be removed in v17\n */\n\nexport function isValidNameError(name) {\n  typeof name === 'string' || devAssert(false, 'Expected name to be a string.');\n\n  if (name.startsWith('__')) {\n    return new GraphQLError(\n      `Name \"${name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n    );\n  }\n\n  try {\n    assertName(name);\n  } catch (error) {\n    return error;\n  }\n}\n/* c8 ignore stop */\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { print } from '../language/printer.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.mjs';\nimport { isSpecifiedScalarType } from '../type/scalars.mjs';\nimport { astFromValue } from './astFromValue.mjs';\nimport { sortValueNode } from './sortValueNode.mjs';\nexport let BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (BreakingChangeType = {}));\n\nexport let DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (DangerousChangeType = {}));\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nexport function findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nexport function findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (isListType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      (isNonNullType(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    (isNamedType(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    (isNonNullType(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      isListType(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if (isNonNullType(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!isNonNullType(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return isNamedType(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if (isScalarType(type)) {\n    return 'a Scalar type';\n  }\n\n  if (isObjectType(type)) {\n    return 'an Object type';\n  }\n\n  if (isInterfaceType(type)) {\n    return 'an Interface type';\n  }\n\n  if (isUnionType(type)) {\n    return 'a Union type';\n  }\n\n  if (isEnumType(type)) {\n    return 'an Enum type';\n  }\n\n  if (isInputObjectType(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction stringifyValue(value, type) {\n  const ast = astFromValue(value, type);\n  ast != null || invariant(false);\n  return print(sortValueNode(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap(oldArray, ({ name }) => name);\n  const newMap = keyMap(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],"names":["version","versionInfo","Object","freeze","major","minor","patch","preReleaseTag","isPromise","value","then","NonErrorThrown","thrownValue","inspect","name","Error","locatedError","rawOriginalError","nodes","path","_nodes","error","originalError","Array","isArray","GraphQLError","message","source","positions","collectSubfields","fn","cache0","a1","a2","a3","undefined","WeakMap","cache1","get","set","cache2","fnResult","memoize3","exeContext","returnType","fieldNodes","_collectSubfields","schema","fragments","variableValues","execute","args","arguments","length","devAssert","document","rootValue","assertValidExecutionArguments","buildExecutionContext","errors","operation","result","executeOperation","data","buildResponse","push","executeSync","rawVariableValues","assertValidSchema","isObjectLike","_definition$name","_operation$variableDe","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","create","definitions","definition","kind","Kind","variableDefinitions","coercedVariableValues","getVariableValues","maxErrors","coerced","defaultFieldResolver","defaultTypeResolver","rootType","getRootType","rootFields","collectFields","selectionSet","OperationTypeNode","executeFields","parentType","sourceValue","fields","values","callbackFn","initialValue","accumulator","resolved","promiseReduce","entries","results","responseName","fieldPath","addPath","executeField","resolvedResult","executeFieldsSerially","object","containsPromise","Promise","all","resolvedValues","resolvedObject","keys","i","_fieldDef$resolve","fieldDef","getFieldDef","type","resolveFn","resolve","info","buildResolveInfo","completed","getArgumentValues","completeValue","rawError","handleFieldError","pathToArray","fieldName","isNonNullType","ofType","isListType","isIterableObject","itemType","completedResults","from","item","index","itemPath","completedItem","completeListValue","isLeafType","serializedResult","serialize","completeLeafValue","isAbstractType","_returnType$resolveTy","resolveTypeFn","resolveType","runtimeType","resolvedRuntimeType","completeObjectValue","ensureValidRuntimeType","completeAbstractValue","isObjectType","invariant","runtimeTypeName","getType","isSubType","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","isTypeOfResult","isTypeOfResults","property","fieldNode","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","getFields","graphql","graphqlImpl","graphqlSync","schemaValidationErrors","validateSchema","parse","syntaxError","validationErrors","validate","isAsyncIterable","maybeAsyncIterable","Symbol","asyncIterator","mapAsyncIterator","iterable","callback","iterator","mapResult","done","return","next","throw","this","subscribe","createSourceEventStream","resultOrStream","mapSourceToResponse","payload","executeSubscription","eventStream","getSubscriptionType","_fieldDef$subscribe","NoSchemaIntrospectionCustomRule","context","Field","node","getNamedType","isIntrospectionType","reportError","getOperationAST","documentAST","getOperationRootType","queryType","mutationType","getMutationType","subscriptionType","introspectionFromSchema","options","optionsWithDefaults","specifiedByUrl","directiveIsRepeatable","schemaDescription","inputValueDeprecation","getIntrospectionQuery","extendSchema","assertSchema","assumeValid","assumeValidSDL","assertValidSDLExtension","schemaConfig","toConfig","extendedConfig","extendSchemaImpl","GraphQLSchema","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","schemaDef","typeDefs","typeExtensionsMap","directiveDefs","schemaExtensions","def","isTypeDefinitionNode","isTypeExtensionNode","extendedTypeName","existingTypeExtensions","concat","typeMap","types","existingType","extendNamedType","_stdTypeMap$name","typeNode","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","directives","map","directive","config","GraphQLDirective","mapValue","extendArg","_node$description","locations","isRepeatable","repeatable","buildArgumentMap","astNode","extensions","extensionASTNodes","replaceType","GraphQLList","GraphQLNonNull","isSpecifiedScalarType","isScalarType","_typeExtensionsMap$co2","specifiedByURL","_getSpecifiedByURL","getSpecifiedByURL","GraphQLScalarType","extendScalarType","_typeExtensionsMap$co3","GraphQLObjectType","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","extendObjectType","isInterfaceType","_typeExtensionsMap$co4","GraphQLInterfaceType","extendInterfaceType","isUnionType","_typeExtensionsMap$co5","GraphQLUnionType","getTypes","buildUnionTypes","extendUnionType","isEnumType","_typeExtensionsMap$ty","GraphQLEnumType","buildEnumValueMap","extendEnumType","isInputObjectType","_typeExtensionsMap$co","GraphQLInputObjectType","field","buildInputFieldMap","extendInputObjectType","arg","opTypes","_node$operationTypes","operationTypesNodes","operationType","_stdTypeMap$name2","getWrappedType","fieldConfigMap","_node$fields","nodeFields","_field$description","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_arg$description","defaultValue","valueFromAST","inputFieldMap","_node$fields2","fieldsNodes","_field$description2","enumValueMap","_node$values","valuesNodes","_value$description","flatMap","_node$interfaces$map","_node$interfaces","_node$types$map","_node$types","_typeExtensionsMap$na","_astNode$description","allNodes","_astNode$description2","_astNode$description3","_astNode$description4","_astNode$description5","_astNode$description6","keyMap","specifiedScalarTypes","introspectionTypes","deprecated","getDirectiveValues","GraphQLDeprecatedDirective","reason","specifiedBy","GraphQLSpecifiedByDirective","url","buildASTSchema","assertValidSDL","specifiedDirectives","stdDirective","every","buildSchema","noLocation","allowLegacyFragmentVariables","lexicographicSortSchema","keyValMap","sortByName","sortTypes","sortFields","sortObjMap","sortBy","x","sortArgs","replaceMaybeType","maybeType","fieldsMap","array","sortValueFn","sortedMap","sort","naturalCompare","key","obj","mapToKey","slice","obj1","obj2","key1","key2","printSchema","printFilteredSchema","n","isSpecifiedDirective","isDefinedType","printIntrospectionSchema","directiveFilter","typeFilter","getDirectives","filter","getTypeMap","printSchemaDefinition","printDescription","printArgs","join","printDirective","printType","Boolean","isSchemaOfCommonNames","scalar","astValue","print","printSpecifiedByURL","printScalar","printImplementedInterfaces","printFields","printObject","printInterface","printUnion","getValues","printDeprecated","printBlock","printEnum","f","printInputValue","printInputObject","String","items","indentation","defaultAST","astFromValue","argDecl","DEFAULT_DEPRECATION_REASON","firstInBlock","blockString","block","isPrintableAsBlockString","prefix","replace","concatAST","documents","doc","separateOperations","operations","depGraph","definitionNode","collectDependencies","separatedDocumentASTs","dependencies","Set","fragmentName","collectTransitiveDependencies","has","collected","fromName","add","immediateDeps","visit","FragmentSpread","stripIgnoredCharacters","sourceObj","isSource","Source","body","lexer","Lexer","strippedBody","wasLastAddedTokenNonPunctuator","advance","TokenKind","currentToken","token","tokenKind","isNonPunctuator","isPunctuatorTokenKind","tokenBody","start","end","printBlockString","minimize","assertValidName","isValidNameError","startsWith","assertName","BreakingChangeType","DangerousChangeType","findBreakingChanges","oldSchema","newSchema","findSchemaChanges","change","findDangerousChanges","schemaChanges","typesDiff","diff","removed","oldType","TYPE_REMOVED","persisted","newType","findEnumTypeChanges","findUnionTypeChanges","findInputObjectTypeChanges","findFieldChanges","findImplementedInterfacesChanges","constructor","TYPE_CHANGED_KIND","typeKindName","findTypeChanges","directivesDiff","oldDirective","DIRECTIVE_REMOVED","newDirective","argsDiff","added","newArg","isRequiredArgument","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","DIRECTIVE_REPEATABLE_REMOVED","location","includes","DIRECTIVE_LOCATION_REMOVED","findDirectiveChanges","fieldsDiff","newField","isRequiredInputField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","possibleTypesDiff","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","ARG_CHANGED_KIND","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","isNamedType","ast","sortValueNode","oldArray","newArray","oldMap","newMap","oldItem","newItem"],"sourceRoot":""}